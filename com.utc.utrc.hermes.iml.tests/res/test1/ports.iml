package iml.ports ;
import iml.lang.* ;
import iml.lang.utils.* ;
import iml.connectivity.* ;


type FlowPoint {
	upperBound : Real ;
	lowerBound : Real ;
}

type FlowPath {
	start : FlowPoint ;
	end : FlowPoint ;
	upperBound : Real ;
	lowerBound : Real ;
	assert : { (end.upperBound = start.upperBound + upperBound) && 
			 (end.lowerBound = start.lowerBound + lowerBound) };
}

flowpath : (FlowPoint,FlowPoint,Real,Real) -> FlowPath :=
fun(x:FlowPoint,y:FlowPoint,l:Real,u:Real) {
	oneof FlowPath{ start = x && end = y && lowerBound = l && upperBound = u }	
}  ;


type EndToEndFlow {
	start : FlowPoint ;
	end : FlowPoint ;
	append : FlowPath -> EndToEndFlow := 
	fun(x:FlowPath){
		oneof EndToEndFlow{
			start=self.start && 
			end.lowerBound = self.end.lowerBound + x.end.lowerBound &&
			end.upperBound = self.end.upperBound + x.end.upperBound 
		} 
	};
}

source : FlowPath -> EndToEndFlow :=
	fun(x:FlowPath){
		oneof EndToEndFlow{start = x.start && end = x.end}
	};
	
type DataPort<T> {
	data : T ;
	flowpoint : FlowPoint ;
} 

type EventPort {
	event : Bool ;
	flowpoint : FlowPoint ;
}

type EventDataPort<T> {
	event : Bool ;
	data : T ;
	flowpoint : FlowPoint ;
}

type FlowConnector<T> {
	connector : Connector<T>;
	flow:FlowPath ;
}

<T>flowconnect : (T,T)->FlowConnector<T> :=
fun(x:T,y:T) {
	oneof FlowConnector<T>{ connector.source = x && connector.target = y}
} ;

flowdelaybound : (EndToEndFlow,Real,Real) -> Bool :=
fun(x:EndToEndFlow,u:Real,l:Real){
	x.end.upperBound - x.start.lowerBound <= u &&
	x.end.lowerBound - x.start.upperBound >= l
};


