package iml.systems ;
import iml.lang.* ;


type Direction enum {IN, OUT, INOUT} ;

trait Connectable {
	
}


/** This is going to be reused in any definition of a port type.
 * It makes sense to have it as a trait.
 */
trait Port refines (Connectable) {
	direction : Direction ;
}

/** It might be useful to define a empty simple port that just has the
 * direction property
 */
type InPort exhibits (Port){
	assert {direction = Direction.IN} ;
};
type OutPort exhibits (Port){
	assert {direction = Direction.OUT} ;
};
type InOutPort exhibits (Port){
	assert {direction = Direction.INOUT} ;
};

/*This is the trait of a type that carries and event */
trait EventCarrier<EventType> {
	event : EventType ;
}

/*This is the trait of a type that carries data */
trait DataCarrier<DataType> {
	data : DataType ;
}


trait EventPort<EventType> refines(Port,EventCarrier<EventType>);
trait DataPort<DateType> refines(Port,DataCarrier<DateType>);
trait EventDataPort<EventType,DataType> refines(Port,EventCarrier<EventType>,DataCarrier<DataType>);

type InEventPort<EventType> exhibits(EventPort<EventType>){
	assert {direction = Direction.IN} ;
};
type InDataPort<DateType> exhibits(DataPort<DateType>){
	assert {direction = Direction.IN} ;
};
type InEventDataPort<EventType,DataType> exhibits(EventDataPort<EventType,DataType>){
	assert {direction = Direction.IN} ;
};

type OutEventPort<EventType> exhibits(EventPort<EventType>){
	assert {direction = Direction.OUT} ;
};
type OutDataPort<DateType> exhibits(DataPort<DateType>){
	assert {direction = Direction.OUT} ;
};
type OutEventDataPort<EventType,DataType> exhibits(EventDataPort<EventType,DataType>){
	assert {direction = Direction.OUT} ;
};

type InOutEventPort<EventType> exhibits(EventPort<EventType>){
	assert {direction = Direction.INOUT} ;
};
type InOutDataPort<DateType> exhibits(DataPort<DateType>){
	assert {direction = Direction.INOUT} ;
};
type InOutEventDataPort<EventType,DataType> exhibits(EventDataPort<EventType,DataType>){
	assert {direction = Direction.INOUT} ;
};

/* This annotation is used on a symbol that belongs
 * to a system type to denote that the symbol
 * represents a component. The type of the system must
 * have a System annotation.
 * 
 */
trait Component { 
	subComponents<T exhibits(Component)> : Int -> T ; 
	ports<T exhibits(Port)> : Int -> T ;
	isRoot : Bool ;
};

//should really be extends or refines
trait System refines(Component) {
	assert {isRoot = true} ;
}

/*A connection is a type of two elements of the same type.
 */
type Connector<SourceType exhibits(Connectable),TargetType exhibits(Connectable)> {
	source : SourceType ;
	target : TargetType ;
};

connect<SourceType exhibits(Connectable),TargetType exhibits(Connectable)> : (SourceType,TargetType) -> Connector<SourceType,TargetType> :=
fun(source:SourceType, target:TargetType) {
	some(c:Connector<SourceType,TargetType>){c.source=source && c.target=target} ;
}
;

delegate<PortType exhibits(Connectable)> : (PortType,PortType) -> Connector<PortType,PortType> :=
fun(source:PortType, target:PortType) {
	some(c:Connector<PortType,PortType>){c.source=source && c.target=target} ;
}
;

type A exhibits(Component) {
	p1 : InDataPort<Int> ;
	p2 : OutDataPort<Real> ;
}

type B exhibits(Component) {
	p1 : InDataPort<Real> ;
	p2 : OutDataPort<Int> ;
}

type S exhibits(Component) {
	//Ports
	p1 : InDataPort<Int> ;
	p2 : OutDataPort<Int> ;
	//Sub-components
	a : A ;
	b : B ;
	//Connections
	c1 : Connector<InDataPort<Int>,InDataPort<Int>> := delegate<InDataPort<Int>>(p1,a.p1) ;
	c2 : Connector<OutDataPort<Real>,InDataPort<Real>> := connect<OutDataPort<Real>,InDataPort<Real>>(a.p2,b.p1) ;
	c3 : Connector<OutDataPort<Real>,OutDataPort<Real>> := delegate<OutDataPort<Real>>(b.p2,p2) ;	
}




