package iml.synchrony ;
import iml.systems.* ;
annotation Let ;

trait Synchronous ;

trait Stream<T> {
	pre : Self ;
	init : Self -> Self ;
	then : Self->Self ;
	current : Self;
	when : Self->Self;
	value : T[] ;
	eq : Self->Stream<Bool> ;
}
 
trait NumericType  {
	plus : (Self,Self)->Self; 
	minus : (Self,Self)->Self; 
	div : (Self,Self)->Self; 
	mult : (Self,Self)->Self; 

	leq : (Self,Self)->Stream<Bool>; 
	geq : (Self,Self)->Stream<Bool>; 
	le : (Self,Self)->Stream<Bool>; 
	gr : (Self,Self)->Stream<Bool>; 
}

type RealStream  exhibits (NumericType,Stream<Real>);
type IntStream  exhibits (NumericType,Stream<Int>);
type BoolStream exhibits (Stream<Bool>);


and : (BoolStream,BoolStream)->BoolStream;
or : (BoolStream,BoolStream)->BoolStream;
not : BoolStream->BoolStream;

ite<T> : (BoolStream,Stream<T>,Stream<T>) -> Stream<T> ;

//node Counter(x0, d:int; r:bool) returns (n:int)
//let
//n = x0 -> if r then x0 else pre(n) + d
//tel

type Counter exhibits(Component, Synchronous) {
	x0: InDataPort<IntStream>;
	d: InDataPort<IntStream>;
	r: InDataPort<BoolStream>;
	n: OutDataPort<IntStream>;
	
	assert {ports<InDataPort<IntStream>>(0) = x0} ;
	
	
	[Let] l:Stream<Bool> := 
	{ 
		n.data.eq( x0.data.then( ite<Int>(r.data, x0.data, n.data.pre.plus(d.data) ) ) ) ;
	} ;
	
}










