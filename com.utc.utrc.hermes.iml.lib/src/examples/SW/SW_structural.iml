package examples.SW.structural ;
import iml.systems.* ;
import iml.contracts.*;
import iml.software.* ;

/*In AADL data can be also used as a components
 * which has sub-components (that are indeed just fields).
 * In this encoding, I am considering data not as components.
 */

/*Coordinate type 
 * AADL distinguishes between types and
 * implementations. In the past, we have 
 * used inclusions to encode AADL into
 * IML. An alternative way would be 
 * to use traits. We cannot use a trait
 * as a type, though, which means that 
 * an AADL type must be an IML type. 
 * The following could be a possible
 * encoding. 
 * */
//This is a trait which is created for each type
//and that contains everything defined in the type
trait CoordinateTrait refines(Data);
//This is a type needed to be able to define constants
//of this type
type Coordinate exhibits(CoordinateTrait) ;
/*The implementation also exhibits the same trait
as the type. Notice that we would need a way 
* to distinguish between the type and the implementation.
* One way is by name but this is not reliable. The other way
* is by looking at the content because types (as above) 
* will always be empty.  However, implementations could
* be empty too. The only reliable way would be to 
* add a trait or annotation to implementations. However, 
* there is no need to recover exactly the same AADL model
* and there is no different between an empty implementation
* and a type.*/
type Coordinate_dot_Impl exhibits(CoordinateTrait) {
	lat : Int ;
	long : Int ;
	alt : Int ;
} ;

trait MapTrait refines(Data) ;
type Map exhibits(MapTrait) ;
type  Map_dot_Impl exhibits(MapTrait) {
	wp1 : Coordinate_dot_Impl ;
	wp2 : Coordinate_dot_Impl ;
	wp3 : Coordinate_dot_Impl ;
	wp4 : Coordinate_dot_Impl ;
}

/** We will need to handle enums differently becasue 
 * the following does not work */
//trait FlightPatternTrait exhibits(Data) enum { ZigZag , StraightLine , Perimeter } ;
//type FlightPattern exhibits(FlightPatternTrait) ;
type FlightPattern exhibits( Data) enum { ZigZag , StraightLine , Perimeter } ; 

trait CommandTrait refines(Data) ;
type Command exhibits(CommandTrait) ;

type Command_dot_Impl exhibits(CommandTrait) {
	Map : Map_dot_Impl ;
	Pattern : FlightPattern ;
	HMAC : Bool ;
}

trait MissionTrait refines(Data) ;
type Mission exhibits(MissionTrait) ;

type Mission_dot_Impl exhibits(MissionTrait) {
	wp1 : Coordinate_dot_Impl ;
	wp2 : Coordinate_dot_Impl ;
	wp3 : Coordinate_dot_Impl ;
	wp4 : Coordinate_dot_Impl ;
	wp5 : Coordinate_dot_Impl ;
	wp6 : Coordinate_dot_Impl ;
	wp7 : Coordinate_dot_Impl ;
	wp8 : Coordinate_dot_Impl ;
	wp9 : Coordinate_dot_Impl ;
	wp10 : Coordinate_dot_Impl ;
}

trait MissionWindowTrait refines(Data) ;
type MissionWindow exhibits(MissionWindowTrait) ;

type  MissionWindow_dot_Impl  {
	wp1 : Coordinate_dot_Impl ;
	wp2 : Coordinate_dot_Impl ;
	wp3 : Coordinate_dot_Impl ;
	wp4 : Coordinate_dot_Impl ;
	crc : Bool ;
}

trait RadioDriverTrait refines(Component,Thread) {
	recv_map_in : InEventDataPort < Bool,Command_dot_Impl > ;
	send_status_out : OutEventDataPort < Bool,Coordinate_dot_Impl > ;
	send_status_in : InEventDataPort < Bool, Coordinate_dot_Impl > ;
	recv_map_out : OutEventDataPort < Bool,Command_dot_Impl > ;
}

type  RadioDriver exhibits (RadioDriverTrait);
type  RadioDriver_dot_Impl exhibits (RadioDriverTrait);


trait  FlightPlannerTrait refines (Component,Thread){
	flight_plan : OutDataPort < Mission_dot_Impl > ;
	recv_map : InEventDataPort < Bool,Command_dot_Impl > ;
	position_status : InEventDataPort < Bool,Coordinate_dot_Impl > ;
}

type FlightPlanner exhibits(FlightPlannerTrait);
type FlightPlanner_dot_Impl exhibits(FlightPlannerTrait);

trait WaypointManagerTrait refines (Component,Thread){
	flight_plan : InDataPort < Mission_dot_Impl > ;
	waypoint : OutEventDataPort < Bool, MissionWindow_dot_Impl > ;
	position_status : InEventDataPort < Bool, Coordinate_dot_Impl > ;
}
type WaypointManager exhibits (WaypointManagerTrait) ;
type WaypointManager_dot_Impl exhibits(WaypointManagerTrait);

trait UARTDriverTrait refines (Component,Thread){
	position_status_in : InEventDataPort < Bool,Coordinate_dot_Impl > ;
	waypoint_out : OutEventDataPort < Bool,MissionWindow_dot_Impl > ;
	position_status_out : OutEventDataPort < Bool,Coordinate_dot_Impl > ;
	waypoint_in : InEventDataPort < Bool,MissionWindow_dot_Impl > ;
}

type UARTDriver exhibits(UARTDriverTrait) ;
type UARTDriver_dot_Impl exhibits(UARTDriverTrait) ;


trait MC_SWTrait refines(Component,Process){
	recv_map : InEventDataPort < Bool,Command_dot_Impl > ;
	send_status : OutEventDataPort < Bool,Coordinate_dot_Impl > ;
	waypoint : OutEventDataPort < Bool,MissionWindow_dot_Impl > ;
	position_status : InEventDataPort < Bool,Coordinate_dot_Impl > ;
}

type MC_SW exhibits(MC_SWTrait) ;

type  MC_SW_dot_Impl exhibits (MC_SWTrait) {
	RADIO : RadioDriver ;
	FPLN : FlightPlanner ;
	WPM : WaypointManager ;
	UART : UARTDriver ;
	
	c1 : Connector < InEventDataPort < Bool,Command_dot_Impl >,InEventDataPort < Bool,Command_dot_Impl > > :=
	connect<InEventDataPort < Bool,Command_dot_Impl >,InEventDataPort < Bool,Command_dot_Impl >>(recv_map,RADIO.recv_map_in) ;
	
	c2 : Connector < OutEventDataPort < Bool,Coordinate_dot_Impl >,OutEventDataPort < Bool,Coordinate_dot_Impl > > := 
	connect < OutEventDataPort < Bool,Coordinate_dot_Impl >,OutEventDataPort < Bool,Coordinate_dot_Impl > >(RADIO.send_status_out,send_status);
	
	c3 : Connector < OutEventDataPort < Bool,Command_dot_Impl >,InEventDataPort < Bool,Command_dot_Impl > > := 
	connect < OutEventDataPort < Bool,Command_dot_Impl >,InEventDataPort < Bool,Command_dot_Impl > >(RADIO.recv_map_out,FPLN.recv_map);
	
	c5 : Connector < OutDataPort < Mission_dot_Impl >, InDataPort<Mission_dot_Impl> > :=
	connect < OutDataPort < Mission_dot_Impl >, InDataPort<Mission_dot_Impl> > (FPLN.flight_plan,WPM.flight_plan)  ;
	
	c6 : Connector < OutEventDataPort < Bool, MissionWindow_dot_Impl >, InEventDataPort < Bool, MissionWindow_dot_Impl > >:= 
	connect < OutEventDataPort < Bool, MissionWindow_dot_Impl >, InEventDataPort < Bool, MissionWindow_dot_Impl > >(WPM.waypoint,UART.waypoint_in) ;
	
	c7 : Connector < OutEventDataPort < Bool, Coordinate_dot_Impl >, InEventDataPort < Bool, Coordinate_dot_Impl > > :=
	 connect < OutEventDataPort < Bool, Coordinate_dot_Impl >, InEventDataPort < Bool, Coordinate_dot_Impl > >(UART.position_status_out, WPM.position_status);
	
	c8 : Connector < OutEventDataPort < Bool, Coordinate_dot_Impl > , InEventDataPort < Bool, Coordinate_dot_Impl >> :=
	 connect < OutEventDataPort < Bool, Coordinate_dot_Impl > , InEventDataPort < Bool, Coordinate_dot_Impl >>(UART.position_status_out,FPLN.position_status);
	
	c9 : Connector < OutEventDataPort < Bool, Coordinate_dot_Impl >, InEventDataPort < Bool, Coordinate_dot_Impl > > := 
	connect < OutEventDataPort < Bool, Coordinate_dot_Impl >, InEventDataPort < Bool, Coordinate_dot_Impl > >(UART.position_status_out, RADIO.send_status_in);

	c10 : Connector < OutEventDataPort < Bool, MissionWindow_dot_Impl >,OutEventDataPort < Bool, MissionWindow_dot_Impl > > := 
	connect < OutEventDataPort < Bool, MissionWindow_dot_Impl >,OutEventDataPort < Bool, MissionWindow_dot_Impl > >(UART.waypoint_out,waypoint);

	c11 : Connector < InEventDataPort < Bool, Coordinate_dot_Impl >, InEventDataPort < Bool, Coordinate_dot_Impl > > :=
	connect < InEventDataPort < Bool, Coordinate_dot_Impl >, InEventDataPort < Bool, Coordinate_dot_Impl > >(position_status, UART.position_status_in);
	
}

