grammar com.utc.utrc.hermes.iml.Iml with org.eclipse.xtext.common.Terminals

generate iml "http://www.utc.com/utrc/hermes/iml/Iml"


import "http://www.eclipse.org/emf/2002/Ecore" as ecore

/* A model is a container for one or more types. It must have a qualified name*/
Model:
	'package' name=QualifiedName ';'
	(imports+=Import ';')*
	(symbols+=Symbol (';')?)*
;

/*A qualified name is a sequence of names separated by dots*/
QualifiedName:
	ID ('.' ID)*;

/*Import statement to access model elements defined outside of the current 
 * model*/
Import:
	'import' importedNamespace=QualifiedNameWithWildcard;

/*A qualified name followed by ".*" denotes all element within the scope 
 * of the prefix*/
QualifiedNameWithWildcard:
	QualifiedName '.*'?;

Symbol :
	SymbolDeclaration|
	ConstrainedType 
;

Doc :
	{Doc}('@' properties+=[ConstrainedType|QualifiedName] descriptions+=STRING)+
;
	

/*Literals used in finite data types */
DomainLiteral:
	name=ID;

RelationInstance:
	Extension |
	Alias |
	MetaRelation
;

Extension :
	{Extension} 'extends'  target=HigherOrderType
;

Alias:
	{Alias} 'sameas'  target=HigherOrderType
;

MetaRelation:
	{MetaRelaion} propertylist=PropertyList  target=HigherOrderType
;

PropertyList:
	'<<' properties+=SymbolDeclaration (',' properties+=SymbolDeclaration)* '>>'
;

ConstrainedType:
	(doc=Doc)?
	(meta?='meta')? 'type' (propertylist=PropertyList)? name=ID
	((finite?='finite' '|'(cardinality=INT |  literals+=DomainLiteral (',' literals+=DomainLiteral)* )'|' )?
	/*Optional template parameters for generic types */
	(template?='<' typeParameter+=ConstrainedType (',' typeParameter+=ConstrainedType)* '>')?
	/* An optional list of type being extended by this type*/
	( relations+=RelationInstance)*
	/* A list of elements defined by this type*/
	('{' (symbols+=SymbolDeclaration ';')* '}')?);

SymbolDeclaration:
	 name=ID (propertylist=PropertyList)? ':' type=HigherOrderType (':=' definition=FolFormula)? 
;

HigherOrderType:
	ArrayType ({HigherOrderType.domain=current} '~>' range=ArrayType)?  
;

ArrayType returns HigherOrderType:
	SimpleTypeReference ({ArrayType.type=current}'['dimension+=TermExpression']' ('['dimension+=TermExpression']')*)? |
	TupleType
;

TupleType returns HigherOrderType:
	{TupleType} '(' ( symbols+=TupleSymbol (',' symbols+=TupleSymbol)*  )? ')'
;

TupleSymbol:
	(name=ID ':')? type=HigherOrderType
;

SimpleTypeReference returns HigherOrderType:
	{SimpleTypeReference} ref=[ConstrainedType|QualifiedName]
	/*Optional type parameters for generic types */
	('<' typeBinding+=HigherOrderType (',' typeBinding+=HigherOrderType)* '>')?
;

/*Entry point for a first order logic formula.*/
FolFormula:
	/*Weakest operators are implication -> and double implication <->*/
	 Formula ({FolFormula.left=current} op=('=>' | '<=>') right=Formula)?;

Formula returns FolFormula:
	QuantifiedFormula  | OrExpression;

/*A quantified formula (universally or existentially quantified) has
 * a list of bound variables and a body defined over those variables.
 */
QuantifiedFormula returns FolFormula:
	op=('forall' | 'exists') scope+=SymbolDeclaration (',' scope+=SymbolDeclaration)* '{' left=FolFormula '}';

/*Disjunction of two formulas */
OrExpression returns FolFormula:
	AndExpression ({OrExpression.left=current} op='||' right=AndExpression)*;

/*Conjunction of two formulas*/
AndExpression returns FolFormula:
	SignedAtomicFormula ({AndExpression.left=current} op='&&' right=SignedAtomicFormula)*;
		
/*Strongest operator is the negation of a formula */
SignedAtomicFormula returns FolFormula:
	{SignedAtomicFormula} (neg?='!')? left=AtomicExpression;
 
AtomicExpression returns FolFormula:
	TermExpression ({AtomicExpression.left=current} rel=RelationKind right=TermExpression)* ;

TruthValue returns TermExpression:
	{TruthValue} (TRUE?='True' | FALSE?='False');

/*Allowed relation kinds are the equality (which can be used over all 
 * objects types), or the ordering relations among numeric types.
 */
enum RelationKind:
	EQ='=' | LESS='<' | GREATER='>' | LEQ='<=' | GEQ='>=';

/*Generic term expression */
TermExpression:
	Addition;
	
/*Addition (or subtraction) of two terms */
Addition returns TermExpression:
	Multiplication ({Addition.left=current} sign=('+' | '-') right=Multiplication)*;

/*Multiplication, division, reminder and modulo of two terms */
Multiplication returns TermExpression:
	TermSelectionExpression ({Multiplication.left=current} sign=('*' | '/' | '%' | 'mod')
	right=TermSelectionExpression)*;

/*Selection of a term is a recursive definition. It is a terminal term followed
 * by the scoping operator :: and by a member terms. The member term is a 
 * symbol possibly followed by type binding information (for generic functions),
 * possibly followed by parameters (for functions)
 */
TermSelectionExpression returns TermExpression:
	TerminalTerm ({TermMemberSelection.receiver=current} '->' member=SymbolReferenceTerm)*
	;

/*A terminal term can be a number, a reference to symbol defined in the scope
 * of the term, a reference to a constant of a finite type, an if-then-else term
 * expression, the keyword this, or a parenthesized term.
 */
TerminalTerm returns TermExpression:
	{NumberLiteral} neg?=('-')? value=INT |
	{FloatNumberLiteral} neg?=('-')? value = FLOAT |
	TupleConstructor | 
	SymbolReferenceTerm |
	IteTermExpression |
	{This} 'this' |
	TruthValue |
	'{' Program '}' |
	{LambdaExpression}'lambda' signature=TupleType '{'definition=Program'}' ;

TupleConstructor:
	{TupleConstructor} '(' elements+=FolFormula (',' elements+=FolFormula)* ')'
;

SymbolReferenceTerm:
	symbol=[Symbol|QualifiedName] (tail=SelectionParameters)? ( arrayAccess?= '['index+=FolFormula']' ('[' index+=FolFormula']')* )? 
;

SelectionParameters:
	TupleConstructor |
	{LiteralSelection} '@' (literal=[DomainLiteral] | intid=INT)
;

IteTermExpression:
	{IteTermExpression} 'if' '(' condition=FolFormula ')' '{' left=TermExpression '}' (=> 'else'  '{' right=TermExpression '}')?;

Program returns TermExpression:
	{Program} ('var' defs+= SymbolDeclaration ';')* 
	          (relations+=FolFormula ';')*
;

terminal EXT_INT: INT ('e'|'E')('-'|'+') INT;
terminal FLOAT returns ecore::EFloat : ('0'..'9')+ '.' ('0'..'9')+;
