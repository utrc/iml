grammar com.utc.utrc.hermes.iml.Iml with org.eclipse.xtext.common.Terminals

generate iml "http://www.utc.com/utrc/hermes/iml/Iml"


import "http://www.eclipse.org/emf/2002/Ecore" as ecore

/* A model is a container for one or more types. It must have a qualified name*/
Model:
	'package' name=QualifiedName ';'
	(imports+=Import ';')*
	(symbols+=Symbol (';')?)*
;



/*A qualified name is a sequence of names separated by dots*/
QualifiedName:
	ID ('.' ID)*;

/*Import statement to access model elements defined outside of the current 
 * model*/
Import:
	'import' importedNamespace=QualifiedNameWithWildcard;

/*A qualified name followed by ".*" denotes all element within the scope 
 * of the prefix*/
QualifiedNameWithWildcard:
	QualifiedName '.*'?;



Symbol :
	SymbolDefinition |
	ConstrainedType 
;


Doc :
	{Doc}('@' properties+=[ConstrainedType|QualifiedName] descriptions+=STRING)+
;
	


/*Literals used in finite data types */
DomainLiteral:
	name=ID;

RelationInstance:
	propertylist=PropertyList  target=HighOrderType
;

PropertyList:
	'<<' properties+=SymbolDefinition (',' properties+=SymbolDefinition)* '>>'
;

ConstrainedType:
	(doc=Doc)?
	(meta?='meta')? 'type' (propertylist=PropertyList)? name=ID
	((finite?='finite' '|'(cardinality=INT |  literals+=DomainLiteral (',' literals+=DomainLiteral)* )'|' )?
	/*Optional template parameters for generic types */
	(template?='<' typeParameter+=ConstrainedType (',' typeParameter+=ConstrainedType)* '>')?
	/* An optional list of type being extended by this type*/
	( relations+=RelationInstance)*
	/* A list of elements defined by this type*/
	('{' (symbols+=SymbolDefinition ';')* '}')?);



SymbolDefinition:
	name=ID (signature=SymbolTuple)? ':' type=HighOrderType (':=' definition=FolFormula)? 
;

SymbolTuple:
	{SymbolTuple} '(' ( symbols+=SymbolDefinition (',' symbols+=SymbolDefinition)*  )? ')'
;

HighOrderType:
	(propertylist=PropertyList)? domain=TypeReference ('~>' range=TypeReference)?  
;

TypeReference:
	((type=[ConstrainedType|QualifiedName]) |
     (tuple='(' elements+=HighOrderType (','  elements+=HighOrderType)* ')')
	)
		('<' typeBinding+=HighOrderType (',' typeBinding+=HighOrderType)* '>')?
		(array?='['dimension+=TermExpression']' ('['dimension+=TermExpression']')*)? 
;

/*Entry point for a first order logic formula.*/
FolFormula:
	/*Weakest operators are implication -> and double implication <->*/
	 Formula ({FolFormula.left=current} symbol=('=>' | '<=>') right=Formula)?;

Formula returns FolFormula:
	QuantifiedFormula  | OrExpression;

/*A quantified formula (universally or existentially quantified) has
 * a list of bound variables and a body defined over those variables.
 */
QuantifiedFormula returns FolFormula:
	symbol=('forall' | 'exists') scope+=SymbolDefinition (',' scope+=SymbolDefinition)* '{' left=FolFormula '}';


/*Disjunction of two formulas */
OrExpression returns FolFormula:
	AndExpression ({OrExpression.left=current} symbol='||' right=AndExpression)*;



/*Conjunction of two formulas*/
AndExpression returns FolFormula:
	SignedAtomicFormula ({AndExpression.left=current} symbol='&&' right=SignedAtomicFormula)*;
	
		
/*Strongest operator is the negation of a formula */
SignedAtomicFormula returns FolFormula:
	(neg?='!')? left=AtomicExpression;


 
AtomicExpression returns FolFormula:
	TermExpression ({AtomicExpression.left=current} rel=RelationKind right=TermExpression)* ;
	

TruthValue returns TermExpression:
	TRUE='True' | FALSE='False';


/*A relation is a predicate with two parameters and 
 * one among a set of possible relation kinds.
 */
//Relation returns Predicate:
//	parameters+=TermExpression rel=RelationKind parameters+=TermExpression;

/*Allowed relation kinds are the equality (which can be used over all 
 * objects types), or the ordering relations among numeric types.
 */
enum RelationKind:
	EQ='=' | LESS='<' | GREATER='>' | LEQ='<=' | GEQ='>=';


/*Generic term expression */
TermExpression:
	Addition;
	
/*Addition (or subtraction) of two terms */
Addition returns TermExpression:
	Multiplication ({Addition.left=current} sign=('+' | '-') right=Multiplication)*;

/*Multiplication, division, reminder and modulo of two terms */
Multiplication returns TermExpression:
	TermSelectionExpression ({Multiplication.left=current} sign=('*' | '/' | '%' | 'mod')
	right=TermSelectionExpression)*;

/*Selection of a term in the scope of another term or of a static type. */
//TermSelectionExpressionOrStaticReference returns TermExpression:
//	TermSelectionExpression  |
//	{StaticRef} ref=StaticReference;
	

/*Selection of a term is a recursive definition. It is a terminal term followed
 * by the scoping operator :: and by a member terms. The member term is a 
 * symbol possibly followed by type binding information (for generic functions),
 * possibly followed by parameters (for functions)
 */
TermSelectionExpression returns TermExpression:
	TerminalTerm ({TermMemberSelection.receiver=current} '->'
	member=[SymbolDefinition]
	//(template?='<' (typeBinding+=TypeReference (',' typeBinding+=TypeReference)*)? '>')?
	(methodinvocation?='('
	(parameters+=TermExpression (',' parameters+=TermExpression)*)? ')')? 
	(arrayindex?='['index+=TermExpression']' ('[' index+=TermExpression']')* )? )*
	;



/*A terminal term can be a number, a reference to symbol defined in the scope
 * of the term, a reference to a constant of a finite type, an if-then-else term
 * expression, the keyword this, or a parenthesized term.
 */
TerminalTerm returns TermExpression:
	//{NumberLiteral} neg?=('-')? value=INT (real?='.' (extdecimal=EXT_INT | decimal=DECIMAL) )?  |
	//{NumberLiteral} neg?=('-')?  ( value=INT | fvalue = FLOAT)  |
	{NumberLiteral} neg?=('-')? value=INT |
	{FloatNumberLiteral} neg?=('-')? value = FLOAT |
	//{Aggregate} value=SecondOrderTerm |
	SymbolRef |
	//{EnumRef} constant=EnumLiteral |
	//{StaticRef} ref=StaticReference |
	{Ite} ite=IteTermExpression |
	{This} 'this' |
	TruthValue |
	'{' Program '}' |
	'(' subformula=FolFormula')';

SymbolRef:
	ref=[Symbol|QualifiedName]
	(
		(
			//('$' typeBinding+=TypeConstructor (',' typeBinding+=TypeConstructor)* '$')?
			'@' (literal=[DomainLiteral] | intid=INT)
		)? 
		((methodinvocation?='(' (parameters+=TermExpression (',' parameters+=TermExpression)*)? ')')? 
		(arrayindex?='['index+=FolFormula']' ('[' index+=FolFormula']')* )?) 
	)
;


IteTermExpression returns TermExpression:
	{IteTermExpression} 'if' '(' condition=FolFormula ')' '{' left=TermExpression '}' (=> 'else'  '{' right=TermExpression '}')?;




Program returns TermExpression:
	{Program} ('var' defs+= SymbolDefinition ';')* 
	          (relations+=FolFormula ';')*
;


EnumLiteral:
	type=TypeReference '@' literal=[DomainLiteral];

//StaticReference:
//	type=[ConstrainedType|QualifiedName] '::' element=TermSelectionExpression;

//SecondOrderTerm:
//	op=SetOp '{'
//	var=SymbolDefinition (=> boundedInt?=':=' lower=TermExpression '..' upper=TermExpression)? '|' expr=FolFormula ',' member=TermExpression
//	'}';

//enum SetOp:
//	SUM='sum' | PROD='prod';



terminal EXT_INT: INT ('e'|'E')('-'|'+') INT;
terminal FLOAT returns ecore::EFloat : ('0'..'9')+ '.' ('0'..'9')+;

	
