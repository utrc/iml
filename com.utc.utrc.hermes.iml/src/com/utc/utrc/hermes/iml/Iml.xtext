grammar com.utc.utrc.hermes.iml.Iml with org.eclipse.xtext.common.Terminals

generate iml "http://www.utc.com/utrc/hermes/iml/Iml"


import "http://www.eclipse.org/emf/2002/Ecore" as ecore

/* A model is a container for one or more types. It must have a qualified name*/
Model:
	'package' name=QualifiedName ';'
	(imports+=Import ';')*
	(symbols+=Symbol (';'))*
;

/*A qualified name is a sequence of names separated by dots*/
QualifiedName:
	ID ('.' ID)*;

/*Import statement to access model elements defined outside of the current 
 * model*/
Import:
	'import' importedNamespace=QualifiedNameWithWildcard;

/*A qualified name followed by ".*" denotes all element within the scope 
 * of the prefix*/
QualifiedNameWithWildcard:
	QualifiedName '.*'?;

Symbol :
	SymbolDeclaration|
	ConstrainedType |
	Assertion
;

Doc :
	{Doc}('@' properties+=[ConstrainedType|QualifiedName] descriptions+=STRING)+
;
	
RelationInstance:
	Extension |
	Alias |
	MetaRelation
;

Extension returns RelationInstance:
	{Extension} 'extends'  target=HigherOrderType
;

Alias returns RelationInstance:
	{Alias} 'sameas'  target=HigherOrderType
;

MetaRelation returns RelationInstance:
	{MetaRelaion} 'relation' propertylist=PropertyList  target=HigherOrderType 
;

PropertyList:
 '[' properties+=SimpleTypeReference (',' properties+=SimpleTypeReference)* ']'
;



ConstrainedType:
	//(doc=Doc)?
	(meta?='meta')? 'type'  (propertylist=PropertyList)? name=ID (template?='<' typeParameter+=TypeParameter (',' typeParameter+=TypeParameter)* '>')? 
	((finite?='finite' cardinality=INT) |  (^enum?='enum' '{' literals+=NonParametricUntypedSymbolDeclaration (',' literals+=NonParametricUntypedSymbolDeclaration)* '}') )?
	/*Optional template parameters for generic types */
	/* An optional list of type being extended by this type*/
	( relations+=RelationInstance)*
	/* A list of elements defined by this type*/
	('{' (symbols+=(SymbolDeclaration|Assertion) ';')* '}')? ;

TypeParameter returns ConstrainedType:
	name=ID
;

SymbolDeclaration:
	(propertylist=PropertyList)?
	 (template?='<' typeParameter+=TypeParameter (',' typeParameter+=TypeParameter)* '>')? name=ID   (':' type=HigherOrderType )?  (':=' definition=FolFormula)? 
;

Assertion returns SymbolDeclaration :
	{Assertion} 'assert' name=ID ':=' definition=FolFormula
;

NonParametricUntypedSymbolDeclaration returns SymbolDeclaration :
	name=ID  
;


NonParametricTypedSymbolDeclaration returns SymbolDeclaration :
	name=ID  ':' type=HigherOrderType 
;

//PrimitiveProperty:
//	{Assertion} 'assertion' |
//	{Assumption} 'assumption' |
//	{Guarantee} 'guarantee'
//;

HigherOrderType:
	ArrayType ({HigherOrderType.domain=current} '->' range=ArrayType)?  
;

ArrayType returns HigherOrderType:
	(SimpleTypeReference|TupleOrExpressionType) ({ArrayType.type=current} (('['dimensions+=OptionalTermExpr']'))+)?
;


//TupleOrExpressionType returns HigherOrderType :
//	{TupleOrExpressionType} (tuple?='Tuple')? '(' ( symbols+=TupleSymbol  (tuple?=',' symbols+=TupleSymbol)* )? ')'
//;

TupleOrExpressionType returns HigherOrderType :
	ExplicitTupleType |
	ParenthesizedExpression	
	
;

ExplicitTupleType returns HigherOrderType :
	{TupleType} 'Tuple(' symbols+=TupleSymbol ')'  
;
	

ParenthesizedExpression returns HigherOrderType :
	(=>('(' TupleSymbol {ExpressionType.symbols+=current}')') |
	 ('(' TupleSymbol {TupleType.symbols+=current} (',' symbols+=TupleSymbol)+  ')') )
;
	
	
	
OptionalTermExpr:
	{OptionalTermExpr} term=TermExpression?
;

//TupleType returns HigherOrderType:
//	{TupleType} '(' ( symbols+=TupleSymbol (',' symbols+=TupleSymbol)*  )? ')'
//;

TupleSymbol returns SymbolDeclaration:
	(name=ID ':')? type=HigherOrderType
;

SimpleTypeReference returns HigherOrderType:
	{SimpleTypeReference} type=[ConstrainedType|QualifiedName]
	/*Optional type parameters for generic types */
	('<' typeBinding+=HigherOrderType (',' typeBinding+=HigherOrderType)* '>')? ('with' '{' subtypeClause=FolFormula '}')?
;

/*Entry point for a first order logic formula.*/
FolFormula:
	/*Weakest operators are implication -> and double implication <->*/
	 Formula ({FolFormula.left=current} op=('=>' | '<=>') right=Formula)?;

Formula returns FolFormula:
	QuantifiedFormula  | OrExpression;

/*A quantified formula (universally or existentially quantified) has
 * a list of bound variables and a body defined over those variables.
 */
QuantifiedFormula returns FolFormula:
	op=('forall' | 'exists')(template?='<' typeParameter+=TypeParameter (',' typeParameter+=TypeParameter)* '>')? '(' scope+=NonParametricTypedSymbolDeclaration (',' scope+=NonParametricTypedSymbolDeclaration)* ')' '{' left=FolFormula '}';

/*Disjunction of two formulas */
OrExpression returns FolFormula:
	AndExpression ({OrExpression.left=current} op='||' right=AndExpression)*;

/*Conjunction of two formulas*/
AndExpression returns FolFormula:
	SignedAtomicFormula ({AndExpression.left=current} op='&&' right=SignedAtomicFormula)*;
		
/*Strongest operator is the negation of a formula */
SignedAtomicFormula returns FolFormula:
	{SignedAtomicFormula} (neg?='!')? left=AtomicExpression;
 
AtomicExpression returns FolFormula:
	TermExpression (=>( {AtomicExpression.left=current} rel=RelationKind ) right=TermExpression)? ;

TruthValue returns TermExpression:
	{TruthValue} (TRUE?='True' | FALSE?='False');

/*Allowed relation kinds are the equality (which can be used over all 
 * objects types), or the ordering relations among numeric types.
 */
enum RelationKind:
	EQ='=' | LESS='<' | GREATER='>' | LEQ='<=' | GEQ='>=';

/*Generic term expression */
TermExpression:
	Addition;
	
/*Addition (or subtraction) of two terms */
Addition returns TermExpression:
	Multiplication ({Addition.left=current} sign=('+' | '-') right=Multiplication)*;


/*Multiplication, division, reminder and modulo of two terms */
Multiplication returns TermExpression:
	TermSelectionExpression ({Multiplication.left=current} sign=('*' | '/' | '%' | 'mod')
	right=TermSelectionExpression)*;



/*Selection of a term is a recursive definition. It is a terminal term followed
 * by the scoping operator :: and by a member terms. The member term is a 
 * symbol possibly followed by type binding information (for generic functions),
 * possibly followed by parameters (for functions)
 */
TermSelectionExpression returns TermExpression:
	TerminalTerm ({TermMemberSelection.receiver=current} '.' member=SymbolReferenceTerm)*
	;

/*A terminal term can be a number, a reference to symbol defined in the scope
 * of the term, a reference to a constant of a finite type, an if-then-else term
 * expression, the keyword this, or a parenthesized term.
 */


TerminalTerm returns TermExpression:
	{NumberLiteral} neg?=('-')? value=INT |
	{FloatNumberLiteral} neg?=('-')? value = FLOAT |
	SymbolReferenceTerm|
	TupleOrFormulaConstructor | 
	TruthValue |
	TypeConstructor |
	IteTermExpression |
	{This} 'this' |
	'{' Program '}' |
	{LambdaExpression}'fun' signature=TupleOrExpressionType '{'definition=Program'}' ;
	

TypeConstructor returns TermExpression:
	{TypeConstructor} 'some' '(' name=ID ':' ref=SimpleTypeReference ')' '{' init=Program '}'
;

TupleOrFormulaConstructor returns TermExpression:
	{TupleOrFormulaConstructor} (tuple?='tuple')? '(' elements+=FolFormula (tuple?=',' elements+=FolFormula)* ')'
;


SymbolReferenceTerm returns TermExpression:
//	{SymbolReferenceTerm}symbol=[ConstrainedType|QualifiedName] (tails+=SymbolReferenceTail)*
{SymbolReferenceTerm}  ('<' typeBinding+=HigherOrderType (',' typeBinding+=HigherOrderType)* '>')? symbol=[Symbol]  (tails+=SymbolReferenceTail)*
;



SymbolReferenceTail:
	TupleOrFormulaConstructor |
	{ArrayAccess}  '['index=FolFormula']'
;

IteTermExpression returns TermExpression:
	{IteTermExpression} 'if' '(' condition=FolFormula ')' '{' left=TermExpression '}' (=> 'else'  '{' right=TermExpression '}')?;

Program returns TermExpression:
	{Program} ('var' defs+= SymbolDeclaration ';')* 
	          (relations+=FolFormula ';')*
;

terminal EXT_INT: INT ('e'|'E')('-'|'+') INT;
terminal FLOAT returns ecore::EFloat : ('0'..'9')+ '.' ('0'..'9')+;