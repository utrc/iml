grammar com.utc.utrc.hermes.iml.Iml with org.eclipse.xtext.common.Terminals

generate iml "http://www.utc.com/utrc/hermes/iml/Iml"


import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	'package' name=QualifiedName ';'
	(imports+=Import ';')*
	(symbols+=Symbol)*
;

QualifiedName:
	ID ('.' ID)*;


Import:
	'import' importedNamespace=QualifiedNameWithWildcard;


QualifiedNameWithWildcard:
	QualifiedName '.*'?;

Symbol :
	SymbolDeclaration ";"|
	ConstrainedType |
	Assertion ";"
;

Doc :
  {Doc}('@' properties+=[ConstrainedType|QualifiedName] descriptions+=STRING)+
;
	
Property returns ImplicitInstanceConstructor:
	{Property} ref=SimpleTypeReference (definition=SequenceTerm)?
;

PropertyList:
 '[' properties+=Property (',' properties+=Property)* ']'
;

TypeWithProperties :
	(properties=PropertyList)? type=HigherOrderType
;

Relation:
	{Extension}( extends?='extends' '(' extensions+=TypeWithProperties (',' extensions+=TypeWithProperties)*')'   ) |
	{Alias}( alias?='is' type=TypeWithProperties  ) |
	{TraitExhibition}( exhibits?='exhibits' '('exhibitions+=TypeWithProperties (',' exhibitions+=TypeWithProperties)*  ')' ) 
;

ConstrainedType:
	(
		{Annotation} 'annotation' | 
	 	{Trait} 'trait' | 
	 	{ConstrainedType} 'type'
	)   
	(propertylist=PropertyList)? 
	name=ID 
	(template?='<' typeParameter+=TypeParameter (',' typeParameter+=TypeParameter)* '>')? 
	( relations += Relation)*
	( restrictions += TypeRestriction)*
	(';' | ('{' (symbols+=(SymbolDeclaration|Assertion) ';')* '}' ";"?)) 
;

TypeRestriction :
	(
		{CardinalityRestriction} (finite?='finite' cardinality=INT) |  
		{EnumRestriction}
		(^enum?='enum' '{' literals+=NonParametricUntypedSymbolDeclaration 
			               (',' literals+=NonParametricUntypedSymbolDeclaration)* '}'
		)
	)
;

TypeParameter returns ConstrainedType:
	name=ID (relations+=Relation)*
;

SymbolDeclaration:
	(propertylist=PropertyList)?
	 (template?='<' typeParameter+=TypeParameter 
	 	            (',' typeParameter+=TypeParameter)* '>')? 
     name=ID   (':' type=HigherOrderType )?  (':=' definition=FolFormula)? 
;

Assertion returns SymbolDeclaration :
	{Assertion} 'assert' (comment=STRING)? (name=ID)? ':' definition=FolFormula
;

NonParametricUntypedSymbolDeclaration returns SymbolDeclaration :
	name=ID  
;


NonParametricTypedSymbolDeclaration returns SymbolDeclaration :
	name=ID  ':' type=HigherOrderType 
;

HigherOrderType:
	ArrayType ({HigherOrderType.domain=current} '->' range=ArrayType)*  
;

ArrayType returns HigherOrderType:
	(SimpleTypeReference|TupleOrExpressionType) 
	   ({ArrayType.type=current} (('['dimensions+=OptionalTermExpr']'))+)?
;


TupleOrExpressionType returns HigherOrderType :
	ExplicitTupleType |
	ParenthesizedTypeExpression	
	
;

ExplicitTupleType returns HigherOrderType :
	{TupleType} 'Tuple' '(' symbols+=TupleSymbol (',' symbols+=TupleSymbol)* ')'  
;
	

ParenthesizedTypeExpression returns HigherOrderType :
	//=>({EmptyTupleType}'('')') |
	=>({ParenthesizedType}'(' subexpression=HigherOrderType  ')') |
	 {TupleType}('(' (symbols+=TupleSymbol (',' symbols+=TupleSymbol)*)?  ')') 
;
	
	
	
OptionalTermExpr:
	{OptionalTermExpr} term=TermExpression?
;


TupleSymbol returns SymbolDeclaration:
	(name=ID ':')? type=HigherOrderType
;

SimpleTypeReference returns HigherOrderType:
	{SelfType} 'Self' |
	{SimpleTypeReference} type=[ConstrainedType|QualifiedName]
	/*Optional type parameters for generic types */
	('<' typeBinding+=HigherOrderType (',' typeBinding+=HigherOrderType)* '>')? 
;

/*Entry point for a first order logic formula.*/
FolFormula:
	/*Weakest operators are implication -> and double implication <->*/
	 Formula ({FolFormula.left=current} op=('=>' | '<=>') right=Formula)?;

Formula returns FolFormula:
	//QuantifiedFormula  | 
	OrExpression;

/*A quantified formula (universally or existentially quantified) has
 * a list of bound variables and a body defined over those variables.
 */
QuantifiedFormula returns TermExpression:
	{QuantifiedFormula} op=('forall' | 'exists')
	(template?='<' typeParameter+=TypeParameter 
		          (',' typeParameter+=TypeParameter)* '>')? 
      '(' scope+=NonParametricTypedSymbolDeclaration 
         (',' scope+=NonParametricTypedSymbolDeclaration)* ')' 
         '{' left=FolFormula '}';

/*Disjunction of two formulas */
OrExpression returns FolFormula:
	AndExpression ({OrExpression.left=current} op='||' right=AndExpression)*;

/*Conjunction of two formulas*/
AndExpression returns FolFormula:
	SignedAtomicFormula ({AndExpression.left=current} op='&&' right=SignedAtomicFormula)*;
		
/*Strongest operator is the negation of a formula */
SignedAtomicFormula returns FolFormula:
	{SignedAtomicFormula} (neg?='!')? left=AtomicExpression;
 
AtomicExpression returns FolFormula:
	TermExpression (=>( {AtomicExpression.left=current} rel=RelationKind ) right=TermExpression)? ;

TruthValue returns TermExpression:
	{TruthValue} (TRUE?='true' | FALSE?='false');

/*Allowed relation kinds are the equality (which can be used over all 
 * objects types), or the ordering relations among numeric types.
 */
enum RelationKind:
	EQ='=' | NEQ='!=' | LESS='<' | GREATER='>' | LEQ='<=' | GEQ='>=';

/*Generic term expression */
TermExpression:
	Addition;
	
/*Addition (or subtraction) of two terms */
Addition returns TermExpression:
	Multiplication ({Addition.left=current} sign=('+' | '-') right=Multiplication)*;


/*Multiplication, division, reminder and modulo of two terms */
Multiplication returns TermExpression:
	TermSelectionExpression ({Multiplication.left=current} sign=('*' | '/' | '%' | 'mod')
	right=TermSelectionExpression)*;



/*Selection of a term is a recursive definition. It is a terminal term followed
 * by the scoping operator :: and by a member terms. The member term is a 
 * symbol possibly followed by type binding information (for generic functions),
 * possibly followed by parameters (for functions)
 */
TermSelectionExpression returns TermExpression:
	TerminalTerm ({TermMemberSelection.receiver=current} '.' member=SymbolReferenceTerm)*
	;

/*A terminal term can be a number, a reference to symbol defined in the scope
 * of the term, a reference to a constant of a finite type, an if-then-else term
 * expression, the keyword this, or a parenthesized term.
 */


TerminalTerm returns TermExpression:
	{NumberLiteral} neg?=('-')? value=INT |
	{FloatNumberLiteral} neg?=('-')? value = FLOAT |
	{String} value = STRING |
	SymbolReferenceTerm |
	TupleOrFormulaConstructor | 
	TruthValue |
	InstanceConstructor |
	IteTermExpression |
	CaseTermExpression |
	{SelfTerm} 'self' |
	SequenceTerm |
	{LambdaExpression}'fun' signature=TupleOrExpressionType definition=SequenceTerm |
	QuantifiedFormula
	 ;
	

InstanceConstructor returns TermExpression:
	{InstanceConstructor} 'some' '(' ref=TupleSymbol ')' definition=SequenceTerm |
	{ImplicitInstanceConstructor}  'oneof' ref=SimpleTypeReference definition=SequenceTerm
;

TupleOrFormulaConstructor returns TermExpression:
	ExplicitTupleConstructor |
	ParenthesizedTerm
;

ExplicitTupleConstructor returns TermExpression:
	{TupleConstructor} 'tuple' '(' elements+=FolFormula (',' elements+=FolFormula)* ')' 
;

ParenthesizedTerm returns TermExpression :
	=>({ParenthesizedTerm}'(' sub=FolFormula ')') |
	TupleConstructor
;

TupleConstructor returns TermExpression:
	//=>({EmptyTuple}'('')') |
	 {TupleConstructor} ('(' (elements+=FolFormula  (',' elements+=FolFormula)*)?  ')') 
;
	



SymbolReferenceTerm returns TermExpression:
{SymbolReferenceTerm}  ('<' typeBinding+=HigherOrderType 
	                       (',' typeBinding+=HigherOrderType)* '>')? 
	                    symbol=[Symbol]  (tails+=SymbolReferenceTail)*
;


SymbolReferenceTail:
	TupleConstructor |
	{ArrayAccess}  '['index=FolFormula']'
;

IteTermExpression returns TermExpression:
	{IteTermExpression} 'if' '(' condition=FolFormula ')' '{' left=TermExpression '}' 
	                                          (=> 'else'  '{' right=TermExpression '}')?;
	                                          
CaseTermExpression returns TermExpression:
	{CaseTermExpression} 'case' '{'
								(cases+=FolFormula ':' expressions+=TermExpression ';')+
						  '}'
								;	                                          

SequenceTerm returns TermExpression:
	{SequenceTerm} '{' ('var' defs+= SymbolDeclaration ';')* 
	         	   	   return=FolFormula '}' 
;

terminal EXT_INT: INT ('e'|'E')('-'|'+') INT;
terminal FLOAT returns ecore::EFloat : ('0'..'9')+ '.' ('0'..'9')+;
