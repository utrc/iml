grammar com.utc.utrc.hermes.iml.Iml with org.eclipse.xtext.common.Terminals

generate iml "http://www.utc.com/utrc/hermes/iml/Iml"


import "http://www.eclipse.org/emf/2002/Ecore" as ecore

/* A model is a container for one or more types. It must have a qualified name*/
Model:
	'package' name=QualifiedName ';'
	(imports+=Import ';')*
	(symbols+=Symbol (';')?)*
;



/*A qualified name is a sequence of names separated by dots*/
QualifiedName:
	ID ('.' ID)*;

/*Import statement to access model elements defined outside of the current 
 * model*/
Import:
	'import' importedNamespace=QualifiedNameWithWildcard;

/*A qualified name followed by ".*" denotes all element within the scope 
 * of the prefix*/
QualifiedNameWithWildcard:
	QualifiedName '.*'?;



Symbol :
	SymbolDeclaration|
	ConstrainedType 
;


Doc :
	{Doc}('@' properties+=[ConstrainedType|QualifiedName] descriptions+=STRING)+
;
	


/*Literals used in finite data types */
DomainLiteral:
	name=ID;

RelationInstance:
	propertylist=PropertyList  target=HigherOrderType
;

PropertyList:
	'<<' properties+=SymbolDeclaration (',' properties+=SymbolDeclaration)* '>>'
;

ConstrainedType:
	(doc=Doc)?
	(meta?='meta')? 'type' (propertylist=PropertyList)? name=ID
	((finite?='finite' '|'(cardinality=INT |  literals+=DomainLiteral (',' literals+=DomainLiteral)* )'|' )?
	/*Optional template parameters for generic types */
	(template?='<' typeParameter+=ConstrainedType (',' typeParameter+=ConstrainedType)* '>')?
	/* An optional list of type being extended by this type*/
	( relations+=RelationInstance)*
	/* A list of elements defined by this type*/
	('{' (symbols+=SymbolDeclaration ';')* '}')?);



SymbolDeclaration:
	name=ID (signature=SymbolTuple)? ':' type=HigherOrderType (':=' definition=FolFormula)? 
;

SymbolTuple:
	{SymbolTuple} '(' ( symbols+=SymbolDeclaration (',' symbols+=SymbolDeclaration)*  )? ')'
;

HigherOrderType:
	(propertylist=PropertyList)? domain=ArrayType ('~>' range=ArrayType)?  
;



ArrayType returns HigherOrderType:
	TypeReference ({ArrayType.type=current}'['dimension+=TermExpression']' ('['dimension+=TermExpression']')*)? 
;

TypeReference returns HigherOrderType:
	SimpleTypeReference |
	{TupleType}'(' types+=HigherOrderType (','  types+=HigherOrderType)* ')'
	
;

SimpleTypeReference returns HigherOrderType:
	{SimpleTypeReference} ref=[ConstrainedType|QualifiedName]
	/*Optional type parameters for generic types */
	('<' typeBinding+=HigherOrderType (',' typeBinding+=HigherOrderType)* '>')?
;


/*Entry point for a first order logic formula.*/
FolFormula:
	/*Weakest operators are implication -> and double implication <->*/
	 Formula ({FolFormula.left=current} symbol=('=>' | '<=>') right=Formula)?;

Formula returns FolFormula:
	QuantifiedFormula  | OrExpression;

/*A quantified formula (universally or existentially quantified) has
 * a list of bound variables and a body defined over those variables.
 */
QuantifiedFormula returns FolFormula:
	symbol=('forall' | 'exists') scope+=SymbolDeclaration (',' scope+=SymbolDeclaration)* '{' left=FolFormula '}';


/*Disjunction of two formulas */
OrExpression returns FolFormula:
	AndExpression ({OrExpression.left=current} symbol='||' right=AndExpression)*;



/*Conjunction of two formulas*/
AndExpression returns FolFormula:
	SignedAtomicFormula ({AndExpression.left=current} symbol='&&' right=SignedAtomicFormula)*;
	
		
/*Strongest operator is the negation of a formula */
SignedAtomicFormula returns FolFormula:
	(neg?='!')? left=AtomicExpression;


 
AtomicExpression returns FolFormula:
	TermExpression ({AtomicExpression.left=current} rel=RelationKind right=TermExpression)* ;
	

TruthValue returns TermExpression:
	TRUE='True' | FALSE='False';


/*A relation is a predicate with two parameters and 
 * one among a set of possible relation kinds.
 */
//Relation returns Predicate:
//	parameters+=TermExpression rel=RelationKind parameters+=TermExpression;

/*Allowed relation kinds are the equality (which can be used over all 
 * objects types), or the ordering relations among numeric types.
 */
enum RelationKind:
	EQ='=' | LESS='<' | GREATER='>' | LEQ='<=' | GEQ='>=';


/*Generic term expression */
TermExpression:
	Addition;
	
/*Addition (or subtraction) of two terms */
Addition returns TermExpression:
	Multiplication ({Addition.left=current} sign=('+' | '-') right=Multiplication)*;

/*Multiplication, division, reminder and modulo of two terms */
Multiplication returns TermExpression:
	TermSelectionExpression ({Multiplication.left=current} sign=('*' | '/' | '%' | 'mod')
	right=TermSelectionExpression)*;

/*Selection of a term in the scope of another term or of a static type. */
//TermSelectionExpressionOrStaticReference returns TermExpression:
//	TermSelectionExpression  |
//	{StaticRef} ref=StaticReference;
	

/*Selection of a term is a recursive definition. It is a terminal term followed
 * by the scoping operator :: and by a member terms. The member term is a 
 * symbol possibly followed by type binding information (for generic functions),
 * possibly followed by parameters (for functions)
 */
TermSelectionExpression returns TermExpression:
	TerminalTerm ({TermMemberSelection.receiver=current} '->'
	member=[SymbolDeclaration]
	//(template?='<' (typeBinding+=TypeReference (',' typeBinding+=TypeReference)*)? '>')?
	(methodinvocation?='('
	(parameters+=TermExpression (',' parameters+=TermExpression)*)? ')')? 
	(arrayindex?='['index+=TermExpression']' ('[' index+=TermExpression']')* )? )*
	;



/*A terminal term can be a number, a reference to symbol defined in the scope
 * of the term, a reference to a constant of a finite type, an if-then-else term
 * expression, the keyword this, or a parenthesized term.
 */
TerminalTerm returns TermExpression:
	//{NumberLiteral} neg?=('-')? value=INT (real?='.' (extdecimal=EXT_INT | decimal=DECIMAL) )?  |
	//{NumberLiteral} neg?=('-')?  ( value=INT | fvalue = FLOAT)  |
	{NumberLiteral} neg?=('-')? value=INT |
	{FloatNumberLiteral} neg?=('-')? value = FLOAT |
	//{Aggregate} value=SecondOrderTerm |
	SymbolRef |
	//{EnumRef} constant=EnumLiteral |
	//{StaticRef} ref=StaticReference |
	{Ite} ite=IteTermExpression |
	{This} 'this' |
	TruthValue |
	'{' Program '}' |
	'(' subformula=FolFormula')';

SymbolRef:
	ref=[Symbol|QualifiedName]
	(
		(
			//('$' typeBinding+=TypeConstructor (',' typeBinding+=TypeConstructor)* '$')?
			'@' (literal=[DomainLiteral] | intid=INT)
		)? 
		((methodinvocation?='(' (parameters+=TermExpression (',' parameters+=TermExpression)*)? ')')? 
		(arrayindex?='['index+=FolFormula']' ('[' index+=FolFormula']')* )?) 
	)
;


IteTermExpression returns TermExpression:
	{IteTermExpression} 'if' '(' condition=FolFormula ')' '{' left=TermExpression '}' (=> 'else'  '{' right=TermExpression '}')?;




Program returns TermExpression:
	{Program} ('var' defs+= SymbolDeclaration ';')* 
	          (relations+=FolFormula ';')*
;


EnumLiteral:
	type=TypeReference '@' literal=[DomainLiteral];

//StaticReference:
//	type=[ConstrainedType|QualifiedName] '::' element=TermSelectionExpression;

//SecondOrderTerm:
//	op=SetOp '{'
//	var=SymbolDefinition (=> boundedInt?=':=' lower=TermExpression '..' upper=TermExpression)? '|' expr=FolFormula ',' member=TermExpression
//	'}';

//enum SetOp:
//	SUM='sum' | PROD='prod';



terminal EXT_INT: INT ('e'|'E')('-'|'+') INT;
terminal FLOAT returns ecore::EFloat : ('0'..'9')+ '.' ('0'..'9')+;

	