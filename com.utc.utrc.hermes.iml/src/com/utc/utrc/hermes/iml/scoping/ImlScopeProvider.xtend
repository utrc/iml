/*
 * generated by Xtext 2.12.0
 */
package com.utc.utrc.hermes.iml.scoping

import com.google.inject.Inject
import com.utc.utrc.hermes.iml.iml.EnumRestriction
import com.utc.utrc.hermes.iml.iml.ImlPackage
import com.utc.utrc.hermes.iml.iml.InstanceConstructor
import com.utc.utrc.hermes.iml.iml.LambdaExpression
import com.utc.utrc.hermes.iml.iml.Model
import com.utc.utrc.hermes.iml.iml.NamedType
import com.utc.utrc.hermes.iml.iml.QuantifiedFormula
import com.utc.utrc.hermes.iml.iml.RecordType
import com.utc.utrc.hermes.iml.iml.SequenceTerm
import com.utc.utrc.hermes.iml.iml.SimpleTypeReference
import com.utc.utrc.hermes.iml.iml.SymbolDeclaration
import com.utc.utrc.hermes.iml.iml.SymbolReferenceTerm
import com.utc.utrc.hermes.iml.iml.TermMemberSelection
import com.utc.utrc.hermes.iml.iml.TupleConstructor
import com.utc.utrc.hermes.iml.typing.ImlTypeProvider
import com.utc.utrc.hermes.iml.typing.TypingServices
import java.util.Arrays
import java.util.HashSet
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.naming.IQualifiedNameConverter
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.eclipse.xtext.scoping.impl.FilteringScope

import static extension org.eclipse.xtext.EcoreUtil2.*
import com.utc.utrc.hermes.iml.iml.MatchStatement
import com.utc.utrc.hermes.iml.iml.Datatype

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 * 
 * @author Alessandro Pinto
 * @author Ayman Elkfrawy
 * 
 */
class ImlScopeProvider extends AbstractDeclarativeScopeProvider {

	@Inject
	private IQualifiedNameConverter qualifiedNameConverter;

	@Inject extension ImlTypeProvider
	
	@Inject extension TypingServices
	
	@Inject ImlImportedNamespaceAwareLocalScopeProvider importedScopeProvider;
	

	override getScope(EObject context, EReference reference) {
		super.getScope(context, reference)
	}

	def boolean isImported(IEObjectDescription iod, Model context) {
		var qn = iod.qualifiedName
		var mqn = qualifiedNameConverter.toQualifiedName(context.name)
		if (qn.startsWith(mqn) && ! iod.name.startsWith(mqn)) {
			return true;
		}
		
		val allImports = newArrayList
		allImports.addAll(importedScopeProvider.getImplicitImports(false).map[it.toString()])
		allImports.addAll(context.imports.map[it.importedNamespace]);
		
		for (imp : allImports) {
			var iqn = qualifiedNameConverter.toQualifiedName(imp)
			var hasW = false;
			if (iqn.lastSegment.equals('*')) {
				hasW = true;
			}
			if (hasW) {
				iqn = iqn.skipLast(1);
				if (qn.startsWith(iqn)) {
					return true;
				}
			} else {
				if (qn.equals(iqn)) {
					return true;
				}
			}
		}

		return false;
	}

	def IScope getGlobalScope(EObject context, EReference r) {
		var global = delegateGetScope(context, r)

		val (IEObjectDescription)=>boolean filter = [ieod|ieod.isImported(context.getContainerOfType(typeof(Model)))]

		global = new FilteringScope(global, filter);
	}

	def scope_SymbolReferenceTerm_symbol(SymbolReferenceTerm context, EReference r) {
		val container = context.eContainer
		if (container instanceof TermMemberSelection) {
			// We are in a term selection and we have parsed the member already
			// We are in the situation "ID.", thus we need to find the symbols in the
			// scope of the ID 
			if (container.member === context) {
				return scope_SymbolReferenceTerm_symbol(container, r)
			}
		}
		return buildNestedScope(context)
	}

	protected def scopeOfNamedType(NamedType type, IScope scope) {
		val superTypes = type.allSuperTypes
		var features = new HashSet
		for (level : superTypes.reverseView) {
			for (t : level) {
				features.addAll(t.symbols)
			}
		}
		return Scopes::scopeFor(features, scope)
	}

	def scope_SymbolReferenceTerm_symbol(TermMemberSelection context, EReference r) {
		var parentScope = IScope::NULLSCOPE
		val receiver = context.receiver

		if (receiver instanceof SymbolReferenceTerm) {
			val symb = (receiver as SymbolReferenceTerm).symbol
			if (symb instanceof Datatype) { // Access constructor
				return Scopes::scopeFor(symb.constructors)
			}
			if (symb instanceof NamedType) {
				// The receiver is a constrained type
				// This is a reference to an enum
				val nt = (receiver as SymbolReferenceTerm).symbol as NamedType
				if (! nt.restrictions.isEmpty) {
					val res = nt.restrictions.filter(EnumRestriction)
					if (! res.isEmpty) {
						return Scopes::scopeFor(res.get(0).literals);
					}
				}
			}
		} 

		var receiverType = receiver.termExpressionType
		
		if (receiverType === null) {
			return parentScope
		}

		if (receiverType instanceof RecordType) {
			return Scopes::scopeFor(receiverType.symbols);
		}

		val superTypes = receiverType.allSuperTypes
		for (level : superTypes.reverseView) {
			var features = new HashSet
			for (t : level) {
				if (t instanceof SimpleTypeReference) {
					var theType = t.type;
					switch (theType) {
						NamedType: features.addAll(theType.symbols)
					}
				}
			}
			parentScope = Scopes::scopeFor(features, parentScope)
		}
		return parentScope
	}

	def scope_SymbolReferenceTerm_symbol(TupleConstructor context, EReference r) {
		return getScope(context.eContainer, r)
	}

	def IScope buildNestedScope(EObject o) {
		if (o === null) {
			return IScope::NULLSCOPE
		}
		switch (o) {
			InstanceConstructor:
				return Scopes::scopeFor(Arrays.asList(o.ref), buildNestedScope(o.eContainer))
			LambdaExpression:
				return Scopes::scopeFor(o.parameters, buildNestedScope(o.eContainer))
			QuantifiedFormula:
				return Scopes::scopeFor(o.scope, buildNestedScope(o.eContainer))
			SequenceTerm:
				return Scopes::scopeFor(o.defs, buildNestedScope(o.eContainer))
			MatchStatement:
				return Scopes::scopeFor(o.paramSymbols, buildNestedScope(o.eContainer))
			Datatype:
				return Scopes::scopeFor(o.constructors,scopeOfNamedType(o, buildNestedScope(o.eContainer)))
			NamedType:
				return scopeOfNamedType(o, buildNestedScope(o.eContainer))
			Model:
				return Scopes::scopeFor(o.symbols, getGlobalScope(o,ImlPackage::eINSTANCE.model_Symbols))
			default:
				return buildNestedScope(o.eContainer)
		}
	}
}
